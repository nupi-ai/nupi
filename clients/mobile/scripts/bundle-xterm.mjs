#!/usr/bin/env node
/**
 * Reads @xterm/xterm and @xterm/addon-fit from node_modules
 * and generates lib/terminal-html.ts with everything inlined.
 *
 * Usage: node scripts/bundle-xterm.mjs
 */

import { readFileSync, writeFileSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = resolve(__dirname, "..");

const xtermJs = readFileSync(
  resolve(root, "node_modules/@xterm/xterm/lib/xterm.js"),
  "utf-8"
);
const xtermCss = readFileSync(
  resolve(root, "node_modules/@xterm/xterm/css/xterm.css"),
  "utf-8"
);
const fitAddonJs = readFileSync(
  resolve(root, "node_modules/@xterm/addon-fit/lib/addon-fit.js"),
  "utf-8"
);

const xtermPkg = JSON.parse(
  readFileSync(resolve(root, "node_modules/@xterm/xterm/package.json"), "utf-8")
);
const fitPkg = JSON.parse(
  readFileSync(
    resolve(root, "node_modules/@xterm/addon-fit/package.json"),
    "utf-8"
  )
);

// Escape backticks and ${} in source strings for template literal embedding
function esc(s) {
  return s.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$\{/g, "\\${");
}

const output = `// AUTO-GENERATED by scripts/bundle-xterm.mjs â€” do not edit manually.
// @xterm/xterm ${xtermPkg.version} | @xterm/addon-fit ${fitPkg.version}
// Run \`npm run bundle-xterm\` to regenerate after updating xterm packages.

const XTERM_CSS = \`${esc(xtermCss)}\`;

const XTERM_JS = \`${esc(xtermJs)}\`;

const FIT_ADDON_JS = \`${esc(fitAddonJs)}\`;

const BRIDGE_JS = \`
var terminal;
var fitAddon;

function initTerminal() {
  terminal = new Terminal({
    cursorBlink: true,
    fontSize: 14,
    fontFamily: "Menlo, Monaco, Courier New, monospace",
    scrollback: 5000,
    theme: {
      background: "#262626",
      foreground: "#d4d4d4",
      cursor: "#d4d4d4",
      selectionBackground: "#264f78"
    }
  });

  fitAddon = new FitAddon.FitAddon();
  terminal.loadAddon(fitAddon);
  terminal.open(document.getElementById("terminal"));
  fitAddon.fit();

  terminal.onData(function(data) {
    window.ReactNativeWebView.postMessage(JSON.stringify({ type: "input", data: data }));
  });

  terminal.onResize(function(size) {
    window.ReactNativeWebView.postMessage(JSON.stringify({
      type: "resize",
      cols: size.cols,
      rows: size.rows
    }));
  });

  window.addEventListener("resize", function() {
    if (fitAddon) {
      fitAddon.fit();
    }
  });

  window.ReactNativeWebView.postMessage(JSON.stringify({ type: "ready" }));
}

function handleMessage(event) {
  try {
    var msg = JSON.parse(typeof event.data === "string" ? event.data : "{}");
    switch (msg.type) {
      case "output":
        if (terminal && msg.data) {
          var binary = atob(msg.data);
          var bytes = new Uint8Array(binary.length);
          for (var i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          terminal.write(bytes);
        }
        break;
      case "resize_instruction":
        if (terminal && msg.cols && msg.rows) {
          terminal.resize(msg.cols, msg.rows);
        }
        break;
      case "clear":
        if (terminal) {
          terminal.clear();
        }
        break;
      case "set_theme":
        if (terminal && msg.background && msg.foreground) {
          terminal.options.theme = {
            background: msg.background,
            foreground: msg.foreground,
            cursor: msg.foreground,
            selectionBackground: msg.selectionBackground || "#264f78"
          };
          document.body.style.background = msg.background;
        }
        break;
    }
  } catch (e) {
    window.ReactNativeWebView.postMessage(JSON.stringify({
      type: "error",
      message: "Bridge error: " + e.message
    }));
  }
}

// Listen on both window and document for Android compatibility
window.addEventListener("message", handleMessage);
document.addEventListener("message", handleMessage);

try {
  initTerminal();
} catch (e) {
  window.ReactNativeWebView.postMessage(JSON.stringify({
    type: "error",
    message: "Init error: " + e.message
  }));
}
\`;

/**
 * Returns a self-contained HTML document embedding xterm.js, the fit addon,
 * and a postMessage/onMessage bridge for React Native WebView communication.
 *
 * Total bundle size: ~500 KB (xterm core + CSS + fit addon + bridge).
 */
export function getTerminalHtml(): string {
  return \`<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #262626; }
#terminal { width: 100%; height: 100%; }
\${XTERM_CSS}
</style>
</head>
<body>
<div id="terminal"></div>
<script>\${XTERM_JS}</script>
<script>\${FIT_ADDON_JS}</script>
<script>\${BRIDGE_JS}</script>
</body>
</html>\`;
}
`;

writeFileSync(resolve(root, "lib/terminal-html.ts"), output, "utf-8");

const sizeKb = Math.round(output.length / 1024);
console.log(
  `Generated lib/terminal-html.ts (${sizeKb} KB) with xterm ${xtermPkg.version} + fit ${fitPkg.version}`
);
